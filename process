#!/bin/bash

set -e

database_path="${1}"
table_name="${2}"
column_indices="${3}"

function join() {
    local IFS="${1}";
    shift;
    echo "$*";
}

function execute() {
    echo "${2}" | sqlite3 "${1}"
}

case "${table_name}" in
    'job_events')
        all_column_definitions=(
            '`time` INTEGER NOT NULL'
            '`missing info` INTEGER'
            '`job ID` INTEGER NOT NULL'
            '`event type` INTEGER NOT NULL'
            '`user` TEXT'
            '`scheduling class` INTEGER'
            '`job name` TEXT'
            '`logical job name` TEXT'
        )
        ;;
    'task_events')
        all_column_definitions=(
            '`time` INTEGER NOT NULL'
            '`missing info` INTEGER'
            '`job ID` INTEGER NOT NULL'
            '`task index` INTEGER NOT NULL'
            '`machine ID` INTEGER'
            '`event type` INTEGER NOT NULL'
            '`user` TEXT'
            '`scheduling class` INTEGER'
            '`priority` INTEGER NOT NULL'
            '`CPU request` REAL'
            '`memory request` REAL'
            '`disk space request` REAL'
            '`different machines restriction` INTEGER'
        )
        ;;
    'task_usage')
        all_column_definitions=(
            '`start time` INTEGER NOT NULL'
            '`end time` INTEGER NOT NULL'
            '`job ID` INTEGER NOT NULL'
            '`task index` INTEGER NOT NULL'
            '`machine ID` INTEGER NOT NULL'
            '`CPU rate` REAL'
            '`canonical memory usage` REAL'
            '`assigned memory usage` REAL'
            '`unmapped page cache` REAL'
            '`total page cache` REAL'
            '`maximum memory usage` REAL'
            '`disk IO time` REAL'
            '`local disk space usage` REAL'
            '`maximum CPU rate` REAL'
            '`maximum disk IO time` REAL'
            '`cycles per instruction` REAL'
            '`memory accesses per instruction` REAL'
            '`sample portion` REAL'
            '`aggregation type` INTEGER'
            '`sampled CPU usage` REAL'
        )
        ;;
    *)
        echo 'No table is given, or it is unknown.' && exit -1
        ;;
esac

if [ -z "${column_indices}" ]; then
    column_count=${#all_column_definitions[@]}
    column_indices=($(seq ${column_count}))
else
    column_indices=(${column_indices})
    column_count=${#column_indices[@]}
fi

for i in $(seq ${column_count}); do
    column_definitions[${i} - 1]=${all_column_definitions[${column_indices[${i} - 1]} - 1]}
done

temporary_path="${table_name}.tmp"

setup_query="""
DROP TABLE IF EXISTS \`${table_name}\`;
CREATE TABLE \`${table_name}\` ($(join ', ' "${column_definitions[@]}"));
"""

write_query="""
.mode csv
.import ${temporary_path} ${table_name}
"""

if [ ! -z "${database_path}" ]; then
    execute "${database_path}" "${setup_query}"
fi

for part_path in $(find ${table_name} -name '*.csv.gz' | sort); do
    echo "Processing ${part_path}..."
    gunzip -c "${part_path}" | cut -d',' -f$(join ',' ${column_indices[@]}) > "${temporary_path}"
    if [ ! -z "${database_path}" ]; then
        execute "${database_path}" "${write_query}"
    else
        execute "${part_path%.csv.gz}.sqlite3" "${setup_query}${write_query}"
    fi
    rm "${temporary_path}"
done
